@:class = import(module:'Matte.Core.Class');
@:Mod16 = import(module:'Mod16Plus.Core');

@:Cartridge = Mod16.Cartridge;
@:AsciiRenderer = Cartridge.subCartridge(name:'ascii-renderer');





@:TILE_HIGHLIGHT_PALETTE = 0;

Cartridge.Palette.set(
    index : TILE_HIGHLIGHT_PALETTE,
    colors : [
        [0, 0, 0],
        [0.5, 0.5, 0.5],
        [0.6, 0.6, 0.6],
        [0.5, 0.5, 1],        
        [0.5, 0.5, 1]
    ]
);



@:TILE_HIGHLIGHT = 0;
Cartridge.Tile.set(
    index: TILE_HIGHLIGHT,
    data: [
        4, 0, 4, 0, 4, 0, 0, 0,
        0, 4, 0, 4, 0, 4, 0, 0,
        4, 0, 4, 0, 4, 0, 0, 0,
        0, 4, 0, 4, 0, 4, 0, 0,
        4, 0, 4, 0, 4, 0, 0, 0,
        0, 4, 0, 4, 0, 4, 0, 0,
        4, 0, 4, 0, 4, 0, 0, 0,
        0, 4, 0, 4, 0, 4, 0, 0
    ]
);


@:TILE_CURSOR = 1;
Cartridge.Tile.set(
    index: TILE_CURSOR,
    data: [
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
        4, 0, 0, 0, 0, 0, 0, 0,
    ]
);

@:DEFAULT_PALETTE_ID = 1;
Cartridge.Palette.set(
    index: DEFAULT_PALETTE_ID,
    colors: [
        [0.5, 0.5, 0.5],
        [0.5, 0.5, 0.5],
        [0.5, 0.5, 0.5],
        [0.5, 0.5, 0.5],
        [0.5, 0.5, 0.5]
    ]
);
@OSC_POOL = 0;

return class(
    name: 'TextArea',
    define:::(this) {
        @mutations = [];
        @onChange_;
        @onNavHor_;
        @onNavVer_;
        @onEnter_;
        @onNewLine_;
        @onDelLine_;
        @defaultPalette_ = [1, 1, 1];
        @shown = true;

        @TEXT_AREA_HEIGHT = 10;
        @TEXT_AREA_WIDTH = 10;
        
        @LINE_LIMIT = 0;
        @layer = 0;
        @GLYPH_WIDTH  = 6;
        @GLYPH_HEIGHT = 8;
        @completionMode = false;
        @:REDRAW_OSCILLATOR = OSC_POOL;
        OSC_POOL+=1;
        @:CURSOR_OSCILLATOR = 1;
        OSC_POOL+=1;
        


        @lines = [''];
        @colors = [[]];
        
        @offsetX = 0;
        @offsetY = 0;
        
        @cursorX = 0;
        @cursorY = 0;

        @selectCursorX = 0;
        @selectCursorY = 0;
        @selectActive = false;

        @scrollX = 0;
        @scrollY = 0;
        
        @refs = [];
        @lastSpriteCount = 0;

        @prevCursorX = 0;
        @prevCursorY = 0;
        @singleLineMode = false;
        
        



        @:drawSelected::(count, x, y, offset) {
             
            @spr = offset;
            
            @chX = 0;
            @chY = 0;

            
            for(0, count)::(i) {
                Cartridge.Sprite.bind(index:spr);
                Cartridge.Sprite. = {
                    tile: TILE_HIGHLIGHT,
                    show:true,
                    layer:layer,
                    x: i * GLYPH_WIDTH +x,
                    y: y,
                    palette:TILE_HIGHLIGHT_PALETTE
                };
                spr += 1;
                chX += 1;
            }
            return spr;            
        };


        @:drawString::(string, x, y, colors) {
            @refs = [];         
            @chX = 0;
            @chY = 0;


            for(0, string->length)::(i) {
                refs->push(value:
                    AsciiRenderer.create(
                        string: string->charAt(index:i),
                        x: chX * GLYPH_WIDTH  + x,
                        y: chY * GLYPH_HEIGHT + y,
                        layer,
                        color: colors[i]
                    )
                );
                chX += 1;
            }
            return refs;
        };



        @:clearCanvas:: {
            refs->foreach(do:::(i, refset) {
                refset->foreach(do:::(n, ref) {                
                    AsciiRenderer.destroy(refs:ref);
                });
            });
            refs = [];
            // clear selected
            for(1, lastSpriteCount)::(i) {
                Cartridge.Sprite.bind(index:i);
                Cartridge.Sprite.show = false;
            }
            lastSpriteCount = 0;
        };
        
        @:CURSOR_SPRITE = 0;
        @cursorCounterFrames = 0;
        Cartridge.Oscillator.bind(index:CURSOR_OSCILLATOR);
        Cartridge.Oscillator. = {
            enable:true,
            periodMS:5,
            onCycle::{
                if (inputCallbackID != empty) ::<= {
                    prevCursorX = ((cursorX - scrollX) * GLYPH_WIDTH        + offsetX);
                    prevCursorY = ((cursorY - scrollY) * GLYPH_HEIGHT+1     + offsetY);
                    Cartridge.Oscillator.bind(index:CURSOR_OSCILLATOR);
                    Cartridge.Sprite.bind(index:CURSOR_SPRITE);
                    Cartridge.Sprite. = {
                        tile: TILE_CURSOR,
                        show: cursorCounterFrames < 120,
                        layer:layer+1,
                        x: prevCursorX,
                        y: prevCursorY,
                        palette:DEFAULT_PALETTE_ID
                    };                    
                    cursorCounterFrames += 1;
                    if (cursorCounterFrames > 200)  
                        cursorCounterFrames = 0;
                };
            }
        };


        @:MIN ::(a, b) <- if (a < b) a else b;

        @redrawActive = false;
        @:redrawLines :: {
            when(redrawActive) empty;
            Cartridge.Oscillator.bind(index:REDRAW_OSCILLATOR);
            Cartridge.Oscillator. = {
                enable:true,
                periodMS:17,
                onCycle::{
                    print(message:"update frame");
                    clearCanvas();                    
                    when(!shown) ::<= {
                        redrawActive = false;
                        Cartridge.Oscillator.bind(index:REDRAW_OSCILLATOR);
                        Cartridge.Oscillator.enable = false;
                    };
                    @spr = 1;
                    @i = 0;
                    for(scrollY, MIN(a:lines->keycount, b:scrollY + TEXT_AREA_HEIGHT))::(index) {
                        when(index < 0) empty;
                        @:line = lines[index];
                        @:colorPath = colors[index];
                        when(line->length == 0) ::<= {
                            i+=1;
                        };

                        @scrolledLine = line->substr(from:scrollX, to:MIN(a:line->length-1, b:scrollX+TEXT_AREA_WIDTH));
                        @scrolledColor = colorPath->subset(from:scrollX, to:MIN(a:line->length-1, b:scrollX+TEXT_AREA_WIDTH));
                        when(scrolledLine == empty || scrolledLine->length == 0) ::<= {
                            i+=1;
                        };


                        if (scrolledColor != empty)
                            refs->push(value:drawString(x:offsetX, y: i*GLYPH_HEIGHT + offsetY, string:scrolledLine, colors:scrolledColor));
                        i+=1;
                    }
                    

                    // use from/t select bounds to draw a tile on each character
                    // selected
                    if (selectActive) ::<= {
                        @:select = getSelectedBounds();
                        // first and only line highlight
                        when (select.fromY == select.toY) ::<= {

                            spr = drawSelected(
                                offset:spr, 
                                x: offsetX + (select.fromX-scrollX)*GLYPH_WIDTH,
                                y: offsetY + (select.fromY-scrollY)*GLYPH_HEIGHT,
                                count: ((select.toX - select.fromX) - scrollX)
                            );
                        };


                        for(select.fromY, select.toY+1)::(i) {
                            @:line = lines[i];
                            when(line->length == 0) empty;
                            @scrolledLine = line->substr(from:scrollX, to:MIN(a:line->length-1, b:scrollX+TEXT_AREA_WIDTH));

                            when(select.fromY == i) ::<= {
                                spr = drawSelected(
                                    offset:spr, 
                                    x: offsetX + (select.fromX-scrollX)*GLYPH_WIDTH,
                                    y: offsetY + (i-scrollY)*GLYPH_HEIGHT,
                                    count: ((line->length - select.fromX) - scrollX)
                                );
                            };

                            when(i >= select.toY) ::<= {
                                spr = drawSelected(
                                    offset:spr, 
                                    x: offsetX + (0-scrollX)*GLYPH_WIDTH,
                                    y: offsetY + (i-scrollY)*GLYPH_HEIGHT,
                                    count: (select.toX - scrollX)
                                );
                            };
                            if (scrolledLine != empty && scrolledLine->length > 0) 
                                spr = drawSelected(
                                    offset:spr, 
                                    x: offsetX + (0-scrollX)*GLYPH_WIDTH,
                                    y: offsetY + (i-scrollY)*GLYPH_HEIGHT,
                                    count: ((scrolledLine->length - 0) - scrollX)
                                );
                            
                        }
                    };       
                    

                    lastSpriteCount = spr;

                    redrawActive = false;
                    Cartridge.Oscillator.bind(index:REDRAW_OSCILLATOR);
                    Cartridge.Oscillator.enable = false;

                }
            };
                
        };


        @:insertText ::(text) {
            @:line = cursorY;
            @:at = cursorX;
            @src = lines[line];
            lines[line] = ::<= {
                when(at > src->length-1) ::<= {
                    for(0, text->length)::(i) {
                        colors[line]->push(value:defaultPalette_);
                    }
                    return src + text;
                };
                when(at == 0) ::<= {
                    for(0, text->length)::(i) {
                        colors[line]->insert(at:i, value:defaultPalette_);
                    }
                    return text + src;
                };                   
                colors[line] = [
                    ...colors[line]->subset(from:0, to:at-1),
                    ...colors[line],
                    ...colors[line]->subset(from:at, to:src->length-1)
                ];
                return src->substr(from:0, to:at-1) + text + src->substr(from:at, to:src->length-1);
            };
            cursorX += text->length;
            movedRight();

            if (onChange_ != empty) onChange_(prevText:src, prevLine:cursorY);

        };
        







        @:movedDown :: {
            cursorCounterFrames = 0;        
            if (cursorY >= lines->keycount) ::<= {
                cursorY = lines->keycount-1;
                cursorX = lines[cursorY]->length;
                movedLeft();
                movedRight();
            };
            if (cursorX > lines[cursorY]->length) ::<= {
                cursorX = lines[cursorY]->length;
                movedLeft();
                movedRight();

            };


            if (cursorY - scrollY > TEXT_AREA_HEIGHT-2) ::<= {
                scrollY = cursorY - (TEXT_AREA_HEIGHT-1);
            };


        };

        @:movedLeft :: {
            cursorCounterFrames = 0;
            if (cursorX < 0) ::<= {
                when (cursorY == 0) cursorX = 0;
                cursorY -= 1;
                cursorX = lines[cursorY]->length;
                movedUp();
            }; 

            if (cursorX < scrollX + 2 && scrollX > 0) ::<= {
                scrollX = cursorX - 2;
                if (scrollX < 0) scrollX = 0;
            };

            if (cursorX > scrollX + TEXT_AREA_WIDTH) ::<= {
                scrollX = cursorX - TEXT_AREA_WIDTH;
            };
            



        };

        @:movedUp :: {        
            cursorCounterFrames = 0;
            if (cursorY < 0) cursorY = 0;
            if (cursorX > lines[cursorY]->length) ::<= {
                cursorX = lines[cursorY]->length;
                movedLeft();
                movedRight();

            };

            if (cursorY - scrollY < 2 && scrollY > 0) ::<= {
                scrollY = cursorY-2;
                
            };


        };

        @:insertNewline :: {
            cursorY += 1;
            cursorX = 0;
            lines->insert(value:'', at:cursorY);  
            colors->insert(value:[], at:cursorY);              
            movedDown();
            movedLeft();        
        };

        @:movedRight :: {
            cursorCounterFrames = 0;        
            if (cursorX > lines[cursorY]->length) ::<= {
                cursorY += 1;
                cursorX = 0;
                movedDown();
                movedLeft();
            };
            if (cursorY >= lines->keycount) ::<= {
                cursorY = lines->keycount-1;
                cursorX = lines[cursorY]->length;  
            };

                
            if (cursorX > scrollX + TEXT_AREA_WIDTH) ::<= {
                scrollX = cursorX - TEXT_AREA_WIDTH;
            };

        };

        @:mergeCursorLine:: {
            when(lines->keycount == 1) empty;
            when(cursorY == 0) empty;
            @oldText = lines[cursorY];
            lines->remove(key:cursorY);
            @oldColor = colors[cursorY];
            colors->remove(key:cursorY);
            cursorY-=1;
            cursorX = lines[cursorY]->length;
            lines[cursorY] = lines[cursorY] + oldText;
            oldColor->foreach(do:::(i, color) {
                colors[cursorY]->push(value:color);
            });
            movedUp();
            movedLeft();
        };




        @inputCallbackID;

        @:keyboardCallback = ::(event, text, key) {
            
            when(event == Mod16.Input.EVENTS.KEY_DOWN) ::<= {
                @preserveSelect = false;
                if (selectActive) ::<= {
                    match(key) {
                      (Mod16.Input.KEYS.LCTRL, Mod16.Input.KEYS.RCTRL): preserveSelect = true,
                      (Mod16.Input.KEYS.LSHIFT, Mod16.Input.KEYS.RSHIFT): preserveSelect = true,
                      (Mod16.Input.KEYS.DOWN, Mod16.Input.KEYS.UP, Mod16.Input.KEYS.LEFT, Mod16.Input.KEYS.RIGHT):::<= {
                          if (shiftMod)
                            preserveSelect = true;
                      },

                      


                      default: ::<= {
                        when(ctrlMod) empty;
                        // remove selected text 
                        @:bounds = getSelectedBounds();
                            

                        when (bounds.fromY == bounds.toY) ::<= {
                            cursorX = bounds.toX;
                            cursorY = bounds.fromY;
                            this.deleteLineText(numChars:(bounds.toX - bounds.fromX));
                        };

                        @index = bounds.fromY;
                        for(bounds.fromY, bounds.toY+1)::(i) {
                            @line = lines[i];
                            when(i == bounds.fromY) ::<= {
                                cursorX = lines[index]->length;
                                cursorY = index;
                                this.deleteLineText(numChars:(line->length - bounds.fromX));
                                index+=1;
                            };
                            when(i == bounds.toY) ::<= {
                                cursorX = bounds.toX;
                                cursorY = index;
                                this.deleteLineText(numChars:(bounds.toX));
                                index+=1;
                                mergeCursorLine();
                            };
                            lines->remove(key:index);
                            colors->remove(key:index);
                                

                        }

                        this.moveCursor(x:bounds.fromX, y:bounds.fromY);
                        redrawLines();
                      }
                    };
                };


                match(key) {
                  (Mod16.Input.KEYS.TAB):::<= {
                    @:line = lines[cursorY];
                    insertText(text:'  ');                                            
                    redrawLines();
                  },

                  (Mod16.Input.KEYS.BACKSPACE):::<= {
                    // already deleted.
                    when(selectActive) empty;

                    // remove newline + merge previous line
                    when(cursorX == 0 || lines[cursorY] == '') ::<= {
                        mergeCursorLine();
                    
                    };

                    this.deleteLineText(numChars:1);
                    movedLeft();

                  },
                  
                  (Mod16.Input.KEYS.UP):::<= {
                    if (onNavVer_ != empty) onNavVer_(dir:1);
                    when (completionMode) empty;
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorY -= 1;
                    movedUp();
                    
                  },
                  
                  (Mod16.Input.KEYS.DOWN):::<= {
                    if (onNavVer_ != empty) onNavVer_(dir:-1);
                    when (completionMode) empty;
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorY += 1;
                    movedDown();
                  },

                  (Mod16.Input.KEYS.LEFT):::<= {
                    if (onNavHor_ != empty) onNavHor_();
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorX -= 1;
                    movedLeft();             
                   },
                  
                  (Mod16.Input.KEYS.RIGHT):::<= {
                    if (onNavHor_ != empty) onNavHor_();
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorX += 1;
                    movedRight();

                  },

                  (Mod16.Input.KEYS.V):::<= {
                    
                    if (ctrlMod) ::<= {
                        this.addText(text:Mod16.clipboard);
                    };
                  },    

                  (Mod16.Input.KEYS.C):::<= {                    
                    if (ctrlMod) ::<= {
                        Mod16.clipboard = this.getSelectedText();
                        // deselect to telegraph successful copy
                        preserveSelect = false;
                    };
                  },    

                  
                  
                  (Mod16.Input.KEYS.RETURN):::<= {
                    when(singleLineMode) empty;
                    when(completionMode) if (onEnter_) onEnter_();;
                    if (onEnter_) onEnter_();
                    when (LINE_LIMIT > 0 && lines->keycount >= LINE_LIMIT)  empty;
                  
                    // return at end
                    when(cursorX >= lines[cursorY]->length) ::<= {
                        insertNewline();   
                    };            
                    
                    // return at start
                    when(cursorX == 0) ::<= {
                        @line = lines[cursorY];
                        lines[cursorY] = '';
                        colors[cursorY] = [];
                        insertNewline();   
                        insertText(text:line);                     
                        cursorX = 0;
                    };
                    



                    @portion = lines[cursorY]->substr(from:cursorX, to:lines[cursorY]->length-1);
                    cursorX = lines[cursorY]->length;
                    this.deleteLineText(numChars:portion->length);
                    insertNewline();
                    insertText(text:portion);
                    cursorX = 0;
                  }
                  
                };
                if (!preserveSelect)
                    selectActive = false;
                redrawLines();
            };

            if (text != empty) ::<= {
                this.addCh(ch:text);    
            };
        };

        
    
        
        @pointerIn = false;
        @pointerCallbackID;
        @scrollCallbackID;
        @ctrlCallbackID;
        @ctrlMod = false;
        @shiftMod = false;
        @holdMod = false;

        // whether the mouse is held
        @mouseDownMod = false;

        // position at which the mouse was held
        @mouseDownX;
        @mouseDownY;        
        

    
        
        this.constructor = ::(defaultPalette, onChange, onNavVertical, onNavHorizontal, onEnter) {
            onChange_ = onChange;
            onNavVer_ = onNavVertical;
            onNavHor_ = onNavHorizontal;
            onEnter_ = onEnter;
            if (defaultPalette != empty)
                defaultPalette_ = defaultPalette;
            
            return this;            
        };


        // returns an object with 
        // the following properties:
        // - fromY, fromX (the start bounds)
        // - toY, toX (the end bounds)
        @: getSelectedBounds :: {
            // first the from and to lines;

            // simple case
            when (cursorY == selectCursorY) ::<= {
                @out = {
                    fromY: cursorY,
                    toY: cursorY,
                };
                if (cursorX < selectCursorX) ::<= {
                    out.fromX = cursorX;
                    out.toX = selectCursorX;
                } else ::<= {
                    out.fromX = selectCursorX;
                    out.toX = cursorX;
                };

                return out;
            };


            @out = {};
            
            if(cursorY < selectCursorY) ::<= {
                out.fromY = cursorY;
                out.toY = selectCursorY;
                out.fromX = cursorX;
                out.toX = selectCursorX;
            } else ::<= {
                out.fromY = selectCursorY;
                out.toY = cursorY;
                out.toX = cursorX;
                out.fromX = selectCursorX;
            };
            return out;
        
        };
        
    
        this.interface = {
            x : {
                set ::(value => Number) {
                    when(value == offsetX) empty;
                    offsetX = value;
                    redrawLines();
                },
                get ::<- offsetX
            },

            y : {
                set ::(value => Number) {
                    when(value == offsetY) empty;
                    offsetY = value;
                    redrawLines();
                },
                get ::<- offsetY
            },
            
            layer : {
                set ::(value => Number) {
                    layer = value;
                }
            },

            scrollX : {
                get ::<- scrollX,
                set ::(value) {
                    if (value < 0) value = 0;
                    when (value->floor == scrollX->floor) empty;
                    scrollX = value;
                    redrawLines();
                    
                }
            },

            scrollY : {
                get ::<- scrollY,
                set ::(value) {
                    when (lines->keycount <= TEXT_AREA_HEIGHT) scrollY = 0;
                    if (value > lines->keycount - TEXT_AREA_HEIGHT) value = lines->keycount - TEXT_AREA_HEIGHT;
                    if (value < 0) value = 0;
                    when (value->floor == scrollY->floor) empty;
                    scrollY = value;
                    redrawLines();
                }
            },
            
            setScroll ::(x, y) {
                this.scrollX = x;
                this.scrollY = y;
            },
                        
                        
            widthChars : {
                set ::(value) {
                    TEXT_AREA_WIDTH = value;
                }
            },
            
            shown : {
                get ::<- shown,
                set ::(value => Boolean) {
                    shown = value;
                    redrawLines();
                    this.editable = shown;
                }
            },
            
            
            width : {
                get ::<- TEXT_AREA_WIDTH * GLYPH_WIDTH                            
            },

            heightChars : {
                set ::(value) {
                    TEXT_AREA_HEIGHT = value;
                }
            },
            
            
            height : {
                get ::<- TEXT_AREA_HEIGHT * GLYPH_HEIGHT                            
            },

            getSelectedText :: {
                when(selectActive == false) '';
                @:bounds = getSelectedBounds();

                when(bounds.toY == bounds.fromY) ::<= {
                    return lines[bounds.fromY]->substr(from:bounds.fromX, to:bounds.toX);
                };
                @out = '';



                for(bounds.fromY, bounds.toY+1)::(i) {
                    when(i == bounds.fromY) ::<= {
                        out = out + lines[i]->substr(from:bounds.fromX, to:lines[i]->length-1);
                    };

                    when(i == bounds.toY) ::<= {
                        out = out + '\n' + lines[i]->substr(from:0, to:bounds.toX);

                    };

                    out = out + '\n' + lines[i];

                }
                return out;                
            },
            
            editable : {
                set::(value => Boolean) {
                    when(value == true) ::<= {
                        when(inputCallbackID != empty) empty;
                        
                        ctrlCallbackID = Mod16.Input.addCallback(
                            device:Mod16.Input.DEVICES.KEYBOARD,
                            callback:::(event, text, key) {
                                if(event == Mod16.Input.EVENTS.KEY_DOWN && key == Mod16.Input.KEYS.LCTRL) ctrlMod = true;
                                if(event == Mod16.Input.EVENTS.KEY_UP   && key == Mod16.Input.KEYS.LCTRL) ctrlMod = false;
                                if(event == Mod16.Input.EVENTS.KEY_DOWN && key == Mod16.Input.KEYS.LSHIFT) shiftMod = true;
                                if(event == Mod16.Input.EVENTS.KEY_UP   && key == Mod16.Input.KEYS.LSHIFT) shiftMod = false;
                                if(event == Mod16.Input.EVENTS.KEY_DOWN && key == Mod16.Input.KEYS.RSHIFT) shiftMod = true;
                                if(event == Mod16.Input.EVENTS.KEY_UP   && key == Mod16.Input.KEYS.RSHIFT) shiftMod = false;
                            }
                        );
                        inputCallbackID = Mod16.Input.addCallback(
                            device:Mod16.Input.DEVICES.KEYBOARD,
                            callback:keyboardCallback
                        );  
                        Cartridge.Sprite.bind(index:CURSOR_SPRITE);
                        Cartridge.Sprite.show = true;          
                        pointerCallbackID = Mod16.Input.addCallback(
                            device:Mod16.Input.DEVICES.POINTER0,
                            callback:::(event, x, y, button) {
                                
                                match(event) {
                                  (Mod16.Input.EVENTS.POINTER_BUTTON_UP): ::<= {
                                    mouseDownMod = false;
                                  },

                                  
                                  (Mod16.Input.EVENTS.POINTER_MOTION): ::<= {
                                    pointerIn = 
                                        x >= offsetX && y >= offsetY &&
                                        x <= offsetX + this.width && y <= offsetY + this.height;
                                        
                                    when(ctrlMod) empty; // dont select when in CTRL mode.
                                    when(mouseDownMod == false) empty;
                                    @:p = this.pixelCoordsToCursor(x, y);
                                    if (p.x != cursorX || p.y != cursorY) ::<= {
                                        // highlight active
                                        selectActive = true;
                                        
                                    };


                                    if (selectCursorX != p.x || selectCursorY != p.y) ::<= {
                                        selectCursorX = p.x;
                                        selectCursorY = p.y;
                                        redrawLines();
                                    };

                                  },
                                    

                                  (Mod16.Input.EVENTS.POINTER_BUTTON_DOWN): ::<= {
                                    // we allow scrolling out if it was already part of 
                                    // a held movement.
                                    when(!pointerIn && mouseDownMod == false) empty;
                                    selectActive = false;
                                    mouseDownMod = true;
                                    mouseDownX = x;
                                    mouseDownY = y;                                    
                                    @:a = this.pixelCoordsToCursor(x, y);        
                                    this.moveCursor(x:a.x, y:a.y);
                                    redrawLines();
                                  }
                                };


                            }
                        );
                        redrawLines();
                    };
                    
                    when(inputCallbackID == empty) empty;
                    Mod16.Input.removeCallback(id:inputCallbackID, device:Mod16.Input.DEVICES.KEYBOARD);
                    Mod16.Input.removeCallback(id:pointerCallbackID, device:Mod16.Input.DEVICES.POINTER0);
                    Mod16.Input.removeCallback(id:ctrlCallbackID, device:Mod16.Input.DEVICES.KEYBOARD);
                    inputCallbackID = empty;
                    Cartridge.Sprite.bind(index:CURSOR_SPRITE);
                    Cartridge.Sprite.show = false;          
                    redrawLines();
                },
                
            },
            
            scrollable : {
                set::(value => Boolean) {
                    when(value == true) ::<= {
                        when(scrollCallbackID != empty) empty;
                        
                        @isDown = false;
                        
                        @lastX = 0;
                        @lastY = 0;
                        @ripple = false;
                        scrollCallbackID = Mod16.Input.addCallback(
                            device:Mod16.Input.DEVICES.POINTER0,
                            callback:::(event, x, y, button) {
                                if (event == Mod16.Input.EVENTS.POINTER_BUTTON_DOWN) holdMod = true;
                                if (event == Mod16.Input.EVENTS.POINTER_BUTTON_UP  ) holdMod = false;

                                if (event == Mod16.Input.EVENTS.POINTER_MOTION) ::<= {
                                    if (holdMod && ctrlMod) ::<= {
                                        if (ripple) ::<= {
                                            this.setScroll(
                                                x: this.scrollX - (x - lastX)/2,
                                                y: this.scrollY - (y - lastY)/2
                                            );
                                        };
                                        ripple = !ripple;
                                    };
                                    
                                    lastX = x;
                                    lastY = y;
                                };

                                if (event == Mod16.Input.EVENTS.POINTER_SCROLL) ::<= {
                                    when(!pointerIn) empty;
                                    this.scrollX -= x;
                                    this.scrollY -= y;                                                
                                };    
                                
                            }
                        );
                        

                    };

                    when(scrollCallbackID == empty) empty;
                    Mod16.Input.removeCallback(id:scrollCallbackID, device:Mod16.Input.DEVICES.POINTER0);
                    scrollCallbackID = empty;
                    

                }
            },
            
            text : {
                get :: {
                    @linesReal = [];
                    lines->foreach(do:::(i, line) {
                        if (i != 0)
                            linesReal->push(value:'\n');
                        linesReal->push(value:line);
                        
                    });
                    return String.combine(strings:linesReal);
                },
                
                
                set ::(value)  {
                    cursorX = 1;
                    cursorY = 0;

                    if (value == '' || value == '\n') ::<= {
                        lines = [''];
                        colors = [[]];
                    } else ::<= {                                                                       
                        lines = value->split(token:'\n');
                        for(0, lines->keycount)::(i) {
                            @:color = [];;
                            @:line = lines[i];                            
                            for(0, line->length)::(n) {
                                color->push(value:defaultPalette_);
                            }
                            
                            colors[i] = color;
                        }

                        lines->foreach(do:::(i, text) {
                            if (onChange_ != empty) onChange_(prevLine:i, prevText:'');
                        });
                    };

                    if (LINE_LIMIT > 0) ::<= {
                        lines = lines->subset(from:0, to:LINE_LIMIT);
                        colors = colors->subset(from:0, to:LINE_LIMIT);
                        if (lines == empty) ::<= {
                            lines = [''];
                            colors = [[]];
                        };
                    };


                    redrawLines();  
                },
            },

            addCh ::(ch) {
                // else, just normal text
                insertText(text:ch);
                redrawLines();
            },

            addText ::(text) {
                text->split(token:'\n')->foreach(do:::(index, line) {
                    if (index > 0) ::<= {
                        cursorY+=1;
                        cursorX=0;
                        lines->insert(value:'', at:cursorY);  
                        colors->insert(value:[], at:cursorY);              
                        movedDown();
                        movedLeft();
                    };
                    insertText(text:line);
                });

                redrawLines();
            },



            deleteLineText::(numChars => Number) {
                // cursor can be [0, line->length]
                when(cursorX == 0) empty;
                when(lines[cursorY]->length == 0) empty;
                cursorCounterFrames = 0;

                @:oldLine = lines[cursorY];

                when(numChars >= lines[cursorY]->length && cursorX >= lines[cursorY]->length) ::<= {
                    lines[cursorY] = '';
                    colors[cursorY] = [];
                    cursorX = 0;
                    if (onChange_ != empty) onChange_(prevText:oldLine, prevLine:cursorY);
                    redrawLines();
                };

                when(numChars >= cursorX) ::<= {
                    colors[cursorY] = colors[cursorY]->subset(from:cursorX, to: lines[cursorY]->length-1);
                    lines[cursorY] = lines[cursorY]->substr(from:cursorX, to: lines[cursorY]->length-1);
                    cursorX = 0;
                    if (onChange_ != empty) onChange_(prevText:oldLine, prevLine:cursorY);
                    redrawLines();
                };

                when(cursorX > lines[cursorY]->length-1) ::<={
                    colors[cursorY] = colors[cursorY]->subset(from:0, to:lines[cursorY]->length-numChars-1);
                    lines[cursorY] = lines[cursorY]->substr(from:0, to:lines[cursorY]->length-numChars-1);
                    cursorX -= numChars;
                    if (onChange_ != empty) onChange_(prevText:oldLine, prevLine:cursorY);
                    redrawLines();
                };
                
                colors[cursorY] = [
                    ...(colors[cursorY]->subset(from:0, to:cursorX-numChars-1)),
                    ...(colors[cursorY]->subset(from:cursorX, to: lines[cursorY]->length-1))
                ];
                lines[cursorY] = 
                    lines[cursorY]->substr(from:0, to:cursorX-numChars-1) +
                    lines[cursorY]->substr(from:cursorX, to: lines[cursorY]->length-1)
                ;
                cursorX -= numChars;
                if (onChange_ != empty) onChange_(prevText:oldLine, prevLine:cursorY);
                redrawLines();

            },
            
            getLine ::(index => Number) => String {
                return lines[index];
            },
            
            getLineCount:: {
                return lines->keycount;
            },
            
            lineLimit : {
                set ::(value) <- LINE_LIMIT = value
            },
            
            setScrollBottom :: {
                if (lines->keycount > TEXT_AREA_HEIGHT) ::<= {
                    scrollY = lines->keycount - TEXT_AREA_HEIGHT;
                };
                redrawLines();
            },
            
            
            // returns an x y set of cursor a cursor position 
            // corresponding to the x y pixel given
            pixelCoordsToCursor::(x, y) {
                @ycursor = scrollY + ((y - offsetY) / GLYPH_HEIGHT);
                if (ycursor < 0) ycursor = 0;
                if (ycursor > lines->keycount-1) ycursor = lines->keycount-1;
                
                ycursor = ycursor->floor;
                
                @xcursor = scrollX + ((x - offsetX) / GLYPH_WIDTH);
                if (xcursor < 0) xcursor = 0;
                if (xcursor > lines[ycursor]->length) xcursor = lines[ycursor]->length;
                
                return {x:xcursor->floor, y:ycursor};
            },
            
            
            // Gets a screen pixel corresponding to the 
            // current cursor location
            cursorToPixelCoords :: {
                @y = offsetY + (cursorY - scrollY) * GLYPH_HEIGHT;                                
                if (y < 0) y = 0;

                @x = offsetX + (cursorX - scrollX) * GLYPH_WIDTH;
                if (x < 0) x = 0;
                
                return {x:x, y:y};
            },
            
            // Starting from the current cursor, finds a 
            // substring and returns the cursor position for it.
            // If no such substring, empty is returned.
            find ::(text) {
                @out = {:::} {
                    for(cursorY, lines->keycount) ::(i) {
                        @index = lines[i]->search(key:text);
                        when(index == -1) empty;
                        
                        send(message:{x:index, y:i});
                    }                        
                };
                when(out != empty) out;
                @out = {:::} {
                    for(0, cursorY) ::(i) {
                        @index = lines[i]->search(key:text);
                        when(index == -1) empty;
                        
                        send(message:{x:index, y:i});
                    }
                };
                // not found
                return out;
            },
            
            
            moveCursor ::(x, y) {
                cursorX = if (x == empty) cursorX else x;
                cursorY = if (y == empty) cursorY else y;
                
                movedDown();
                movedUp();
                movedLeft();
                movedRight();
                
                redrawLines();
                if (onNavVer_ != empty) onNavVer_(dir:0);
                if (onNavHor_ != empty) onNavHor_();

            },
            
            cursorY : {
                get :: <- cursorY
            },

            cursorX : {
                get :: <- cursorX
            },
            
            // clears all characters from the drawn view


            // in completion mode, the up / down / enter keys 
            // are ignored            
            completionMode : {
                set ::(value) <- completionMode = value,
                get ::(value) <- completionMode
            },
            
            // in singleLineMode, newlines are ignored as input
            singleLineMode : {
                set ::(value => Boolean) {
                    singleLineMode = value;
                }
            },
            
            defaultPalette : {
                set::(value) {
                    Cartridge.Palette.set(
                        index:DEFAULT_PALETTE_ID,
                        colors: [
                            value,
                            value,
                            value,
                            value,
                            value
                        
                        ]
                    );
                    defaultPalette_ = value;
                    redrawLines();                    
                }
            },
            
            
            
            setColor ::(paletteColor => Object, fromX => Number, fromY => Number, toX => Number, toY => Number) {
                when(toY < fromY) print(message:'toY'+toY+' fromY'+fromY);
                when(toY >= colors->keycount || fromY >= colors->keycount) print(message:'toY'+toY+' numColLines'+colors->keycount);
                when(toY < 0) empty;
                when(fromY == toY) ::<= {
                    @color = colors[fromY];
                    for(fromX, toX+1) ::(x) {
                        color[x] = paletteColor;
                    }
                };
                
                
                when(fromY < toY) ::<= {
                    @color = colors[fromY];
                    for(fromX, color->length)::(x) {
                        color[x] = paletteColor;
                    }


                    for(fromY, toY)::(y) {
                        color = colors[y];
                        for(0, color->length)::(x) {
                            color[x] = paletteColor;
                        }
                    }

                    color = colors[toY];
                    for(0, toX+1) ::(x) {
                        color[x] = paletteColor;
                    }

                };
            
            }

        };
    }
);



