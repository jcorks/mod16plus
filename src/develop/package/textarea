@:class = import(module:'Matte.Core.Class');
@:SES = import(module:'SES.Core');
@:Debug = import(module:'SES.Debug');
@:Fetcher = import(module:'fetcher');





@:TILE_HIGHLIGHT_PALETTE = Fetcher.Palette.newID();
SES.Palette.set(
    index : TILE_HIGHLIGHT_PALETTE,
    colors : [
        [0, 0, 0],
        [0.5, 0.5, 0.5],
        [0.6, 0.6, 0.6],
        [0.5, 0.5, 1]
    ]
);


return class(
    name: 'TextArea',
    define:::(this) {
        @spriteOffset_ = 0;
        @onChange_;
        @onNavHor_;
        @onNavVer_;
        @onEnter_;
        @onNewLine_;
        @onDelLine_;
        @defaultPalette_ = 0;
        @shown = true;

        @TEXT_AREA_HEIGHT = 10;
        @TEXT_AREA_WIDTH = 10;
        
        @LINE_LIMIT = 0;
        @layer = 0;
        @GLYPH_WIDTH  = 6;
        @GLYPH_HEIGHT = 8;
        @completionMode = false;
        @:REDRAW_OSCILLATOR = Fetcher.Oscillator.newID();

        


        @lines = [''];
        @colors = [[]];
        
        @offsetX = 0;
        @offsetY = 0;
        
        @cursorX = 0;
        @cursorY = 0;

        @selectCursorX = 0;
        @selectCursorY = 0;
        @selectActive = false;

        @scrollX = 0;
        @scrollY = 0;
        
        @lastSpriteCount = 0;


        @:TILE_HIGHLIGHT = Fetcher.Tile.newID();
        SES.Tile.set(
            index: TILE_HIGHLIGHT,
            data: [
                4, 0, 4, 0, 4, 0, 4, 0,
                0, 4, 0, 4, 0, 4, 0, 4,
                4, 0, 4, 0, 4, 0, 4, 0,
                0, 4, 0, 4, 0, 4, 0, 4,
                4, 0, 4, 0, 4, 0, 4, 0,
                0, 4, 0, 4, 0, 4, 0, 4,
                4, 0, 4, 0, 4, 0, 4, 0,
                0, 4, 0, 4, 0, 4, 0, 4
            ]
        );



        @:drawSelected::(count, x, y, offset) {
             
            @spr = offset;
            
            @chX = 0;
            @chY = 0;

            
            [0, count]->for(do:::(i) {
                SES.Sprite.set(
                    index: spr,
                    tile: TILE_HIGHLIGHT,
                    show:true,
                    layer,
                    x: i * GLYPH_WIDTH +x,
                    y: y,
                    effect: SES.Sprite.EFFECTS.Color,
                    palette:TILE_HIGHLIGHT_PALETTE
                );                    
                spr += 1;
                chX += 1;
            });
            return spr;            
        };


        @:drawString::(string, x, y, offset, colors) {
             
            @spr = offset;
            
            @chX = 0;
            @chY = 0;


            [0, string->length]->for(do:::(i) {
                SES.Sprite.set(
                    index: spr,
                    tile: string->charCodeAt(index:i),
                    show:true,
                    layer,
                    x: chX * GLYPH_WIDTH  + x,
                    y: chY * GLYPH_HEIGHT + y,
                    palette: colors[i]
                );
                spr += 1;
                chX += 1;
            });
            return spr;
        };



        @:clearCanvas:: {
            [spriteOffset_, lastSpriteCount]->for(do:::(i) {
                SES.Sprite.set(
                    index:i,
                    show:false
                );
            });

        };


        @:MIN ::(a, b) <- if (a < b) a else b;

        @redrawActive = false;
        @:redrawLines :: {
            when(redrawActive) empty;
            SES.Oscillator.set(
                enable:true,
                index:REDRAW_OSCILLATOR,
                periodMS:17,
                onCycle::{
                    when(!shown) ::<= {
                        clearCanvas();
                        redrawActive = false;
                        SES.Oscillator.set(index:REDRAW_OSCILLATOR, enable:false);
                    };
                    @spr = spriteOffset_;
                    @i = 0;
                    [scrollY, MIN(a:lines->keycount, b:scrollY + TEXT_AREA_HEIGHT)]->for(do:::(index) {
                        @:line = lines[index];
                        @:colorPath = colors[index];
                        when(line->length == 0) ::<= {
                            i+=1;
                        };

                        @scrolledLine = line->substr(from:scrollX, to:MIN(a:line->length-1, b:scrollX+TEXT_AREA_WIDTH));
                        @scrolledColor = colorPath->subset(from:scrollX, to:MIN(a:line->length-1, b:scrollX+TEXT_AREA_WIDTH));
                        when(scrolledLine == empty || scrolledLine->length == 0) ::<= {
                            i+=1;
                        };


                        if (scrolledColor != empty)
                            spr = drawString(offset:spr, x:offsetX, y: i*GLYPH_HEIGHT + offsetY, string:scrolledLine, colors:scrolledColor);
                        i+=1;
                    });
                    

                    // use from/t select bounds to draw a tile on each character
                    // selected
                    if (selectActive) ::<= {
                        @:select = getSelectedBounds();
                        // first and only line highlight
                        when (select.fromY == select.toY) ::<= {

                            spr = drawSelected(
                                offset:spr, 
                                x: offsetX + (select.fromX-scrollX)*GLYPH_WIDTH,
                                y: offsetY + (select.fromY-scrollY)*GLYPH_HEIGHT,
                                count: ((select.toX - select.fromX) - scrollX)
                            );
                        };


                        [select.fromY, select.toY+1]->for(do:::(i) {
                            @:line = lines[i];
                            when(line->length == 0) empty;
                            @scrolledLine = line->substr(from:scrollX, to:MIN(a:line->length-1, b:scrollX+TEXT_AREA_WIDTH));

                            when(select.fromY == i) ::<= {
                                spr = drawSelected(
                                    offset:spr, 
                                    x: offsetX + (select.fromX-scrollX)*GLYPH_WIDTH,
                                    y: offsetY + (i-scrollY)*GLYPH_HEIGHT,
                                    count: ((line->length - select.fromX) - scrollX)
                                );
                            };

                            when(i >= select.toY) ::<= {
                                spr = drawSelected(
                                    offset:spr, 
                                    x: offsetX + (0-scrollX)*GLYPH_WIDTH,
                                    y: offsetY + (i-scrollY)*GLYPH_HEIGHT,
                                    count: (select.toX - scrollX)
                                );
                            };
                            if (scrolledLine->length > 0) 
                                spr = drawSelected(
                                    offset:spr, 
                                    x: offsetX + (0-scrollX)*GLYPH_WIDTH,
                                    y: offsetY + (i-scrollY)*GLYPH_HEIGHT,
                                    count: ((scrolledLine->length - 0) - scrollX)
                                );
                            
                        });
                    };

                    [spr, lastSpriteCount]->for(do:::(i) {
                        SES.Sprite.set(
                            index:i,
                            show:false
                        );
                    });           
                    
                    // cursor
                    if (inputCallbackID != empty) ::<= {
                        SES.Sprite.set(
                            index: spr,
                            tile: 0,
                            show:true,
                            layer,
                            x: (cursorX - scrollX) * GLYPH_WIDTH     + offsetX,
                            y: (cursorY - scrollY) * GLYPH_HEIGHT +1 + offsetY,
                            effect: SES.Sprite.EFFECTS.Color,
                            palette:defaultPalette_
                        );                    
                        lastSpriteCount = spr+1;
                    } else 
                        lastSpriteCount = spr;

                    redrawActive = false;
                    SES.Oscillator.set(index:REDRAW_OSCILLATOR, enable:false);

                }
            );
                
        };


        @:insertText ::(text) {
            @:line = cursorY;
            @:at = cursorX;
            @src = lines[line];
            lines[line] = ::<= {
                when(at > src->length-1) ::<= {
                    [0, text->length]->for(do:::(i) {
                        colors[line]->push(value:defaultPalette_);
                    });
                    return src + text;
                };
                when(at == 0) ::<= {
                    [0, text->length]->for(do:::(i) {
                        colors[line]->insert(at:i, value:defaultPalette_);
                    });
                    return text + src;
                };                   

                colors[line] = [
                    ...colors[line]->subset(from:0, to:at-1),
                    colors[line],
                    ...colors[line]->subset(from:at, to:src->length-1)
                ];
                return src->substr(from:0, to:at-1) + text + src->substr(from:at, to:src->length-1);
            };
            cursorX += text->length;
            movedRight();

            if (onChange_ != empty) onChange_(prevText:src, prevLine:cursorY);

        };
        







        @:movedDown :: {
            if (cursorY >= lines->keycount) ::<= {
                cursorY = lines->keycount-1;
                cursorX = lines[cursorY]->length;
                movedLeft();
                movedRight();
            };
            if (cursorX > lines[cursorY]->length) ::<= {
                cursorX = lines[cursorY]->length;
                movedLeft();
                movedRight();

            };


            if (cursorY - scrollY > TEXT_AREA_HEIGHT-2) ::<= {
                scrollY = cursorY - (TEXT_AREA_HEIGHT-1);
            };


        };

        @:movedLeft :: {
            if (cursorX < 0) ::<= {
                when (cursorY == 0) cursorX = 0;
                cursorY -= 1;
                cursorX = lines[cursorY]->length;
                movedUp();
            }; 

            if (cursorX < scrollX + 2 && scrollX > 0) ::<= {
                scrollX = cursorX - 2;
                if (scrollX < 0) scrollX = 0;
            };

            if (cursorX > scrollX + TEXT_AREA_WIDTH) ::<= {
                scrollX = cursorX - TEXT_AREA_WIDTH;
            };
            



        };

        @:movedUp :: {
            if (cursorY < 0) cursorY = 0;
            if (cursorX > lines[cursorY]->length) ::<= {
                cursorX = lines[cursorY]->length;
                movedLeft();
                movedRight();

            };

            if (cursorY - scrollY < 2 && scrollY > 0) ::<= {
                scrollY = cursorY-2;
                
            };


        };

        @:insertNewline :: {
            cursorY += 1;
            cursorX = 0;
            lines->insert(value:'', at:cursorY);  
            colors->insert(value:[], at:cursorY);              
            movedDown();
            movedLeft();        
        };

        @:movedRight :: {
            if (cursorX > lines[cursorY]->length) ::<= {
                cursorY += 1;
                cursorX = 0;
                movedDown();
                movedLeft();
            };
            if (cursorY >= lines->keycount) ::<= {
                cursorY = lines->keycount-1;
                cursorX = lines[cursorY]->length;  
            };

                
            if (cursorX > scrollX + TEXT_AREA_WIDTH) ::<= {
                scrollX = cursorX - TEXT_AREA_WIDTH;
            };

        };

        @:mergeCursorLine:: {
            when(lines->keycount == 1) empty;
            when(cursorY == 0) empty;
            @oldText = lines[cursorY];
            lines->remove(key:cursorY);
            @oldColor = colors[cursorY];
            colors->remove(key:cursorY);
            cursorY-=1;
            cursorX = lines[cursorY]->length;
            lines[cursorY] = lines[cursorY] + oldText;
            oldColor->foreach(do:::(i, color) {
                colors[cursorY]->push(value:color);
            });
            movedUp();
            movedLeft();
        };




        @inputCallbackID;

        @:keyboardCallback = ::(event, text, key) {
            
            when(event == SES.Input.EVENTS.KEY_DOWN) ::<= {
                @preserveSelect = false;
                if (selectActive) ::<= {
                    match(key) {
                      (SES.Input.KEYS.LCTRL, SES.Input.KEYS.RCTRL): preserveSelect = true,
                      (SES.Input.KEYS.LSHIFT, SES.Input.KEYS.RSHIFT): preserveSelect = true,
                      (SES.Input.KEYS.DOWN, SES.Input.KEYS.UP, SES.Input.KEYS.LEFT, SES.Input.KEYS.RIGHT):::<= {
                          if (shiftMod)
                            preserveSelect = true;
                      },

                      


                      default: ::<= {
                        when(ctrlMod) empty;
                        // remove selected text 
                        @:bounds = getSelectedBounds();
                            

                        when (bounds.fromY == bounds.toY) ::<= {
                            cursorX = bounds.toX;
                            cursorY = bounds.fromY;
                            this.deleteLineText(numChars:(bounds.toX - bounds.fromX));
                        };

                        @index = bounds.fromY;
                        [bounds.fromY, bounds.toY+1]->for(do:::(i) {
                            @line = lines[i];
                            when(i == bounds.fromY) ::<= {
                                cursorX = lines[index]->length;
                                cursorY = index;
                                this.deleteLineText(numChars:(line->length - bounds.fromX));
                                index+=1;
                            };
                            when(i == bounds.toY) ::<= {
                                cursorX = bounds.toX;
                                cursorY = index;
                                this.deleteLineText(numChars:(bounds.toX));
                                index+=1;
                                mergeCursorLine();
                            };
                            lines->remove(key:index);
                            colors->remove(key:index);
                                

                        });

                        this.moveCursor(x:bounds.fromX, y:bounds.fromY);
                        redrawLines();
                      }
                    };
                };


                match(key) {
                  (SES.Input.KEYS.TAB):::<= {
                    @:line = lines[cursorY];
                    insertText(text:'  ');                                            
                    redrawLines();
                  },

                  (SES.Input.KEYS.BACKSPACE):::<= {
                    // already deleted.
                    when(selectActive) empty;

                    // remove newline + merge previous line
                    when(cursorX == 0 || lines[cursorY] == '') ::<= {
                        mergeCursorLine();
                    
                    };

                    this.deleteLineText(numChars:1);
                    movedLeft();

                  },
                  
                  (SES.Input.KEYS.UP):::<= {
                    if (onNavVer_ != empty) onNavVer_(dir:1);
                    when (completionMode) empty;
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorY -= 1;
                    movedUp();
                    
                  },
                  
                  (SES.Input.KEYS.DOWN):::<= {
                    if (onNavVer_ != empty) onNavVer_(dir:-1);
                    when (completionMode) empty;
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorY += 1;
                    movedDown();
                  },

                  (SES.Input.KEYS.LEFT):::<= {
                    if (onNavHor_ != empty) onNavHor_();
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorX -= 1;
                    movedLeft();             
                   },
                  
                  (SES.Input.KEYS.RIGHT):::<= {
                    if (onNavHor_ != empty) onNavHor_();
                    if (shiftMod && !selectActive) ::<= {
                        preserveSelect = true;
                        selectActive = true;
                        selectCursorX = cursorX;
                        selectCursorY = cursorY;
                    };
                    cursorX += 1;
                    movedRight();

                  },

                  (SES.Input.KEYS.V):::<= {
                    
                    if (ctrlMod) ::<= {
                        this.addText(text:SES.clipboard);
                    };
                  },    

                  (SES.Input.KEYS.C):::<= {                    
                    if (ctrlMod) ::<= {
                        SES.clipboard = this.getSelectedText();
                        // deselect to telegraph successful copy
                        preserveSelect = false;
                    };
                  },    

                  
                  
                  (SES.Input.KEYS.RETURN):::<= {
                    when(completionMode) if (onEnter_) onEnter_();;
                    if (onEnter_) onEnter_();
                    when (LINE_LIMIT > 0 && lines->keycount >= LINE_LIMIT)  empty;
                  
                    // return at end
                    when(cursorX >= lines[cursorY]->length) ::<= {
                        insertNewline();   
                    };            
                    
                    // return at start
                    when(cursorX == 0) ::<= {
                        @line = lines[cursorY];
                        lines[cursorY] = '';
                        colors[cursorY] = [];
                        insertNewline();   
                        insertText(text:line);                     
                        cursorX = 0;
                    };
                    



                    @portion = lines[cursorY]->substr(from:cursorX, to:lines[cursorY]->length-1);
                    cursorX = lines[cursorY]->length;
                    this.deleteLineText(numChars:portion->length);
                    insertNewline();
                    insertText(text:portion);
                    cursorX = 0;
                  }
                  
                };
                if (!preserveSelect)
                    selectActive = false;
                redrawLines();
            };

            if (text != empty) ::<= {
                this.addCh(ch:text);    
            };
        };

        
    
        
        
        @pointerCallbackID;
        @scrollCallbackID;
        @ctrlCallbackID;
        @ctrlMod = false;
        @shiftMod = false;
        @holdMod = false;

        // whether the mouse is held
        @mouseDownMod = false;

        // position at which the mouse was held
        @mouseDownX;
        @mouseDownY;        
        

    
        
        this.constructor = ::(spriteOffset, defaultPalette, onChange, onNavVertical, onNavHorizontal, onEnter) {
            onChange_ = onChange;
            onNavVer_ = onNavVertical;
            onNavHor_ = onNavHorizontal;
            onEnter_ = onEnter;
            spriteOffset_ = spriteOffset;
            defaultPalette_ = defaultPalette;
            
            return this;            
        };


        // returns an object with 
        // the following properties:
        // - fromY, fromX (the start bounds)
        // - toY, toX (the end bounds)
        @: getSelectedBounds :: {
            // first the from and to lines;

            // simple case
            when (cursorY == selectCursorY) ::<= {
                @out = {
                    fromY: cursorY,
                    toY: cursorY,
                };
                if (cursorX < selectCursorX) ::<= {
                    out.fromX = cursorX;
                    out.toX = selectCursorX;
                } else ::<= {
                    out.fromX = selectCursorX;
                    out.toX = cursorX;
                };

                return out;
            };


            @out = {};
            
            if(cursorY < selectCursorY) ::<= {
                out.fromY = cursorY;
                out.toY = selectCursorY;
                out.fromX = cursorX;
                out.toX = selectCursorX;
            } else ::<= {
                out.fromY = selectCursorY;
                out.toY = cursorY;
                out.toX = cursorX;
                out.fromX = selectCursorX;
            };
            return out;
        
        };
        
    
        this.interface = {
            x : {
                set ::(value => Number) {
                    when(value == offsetX) empty;
                    offsetX = value;
                    redrawLines();
                },
                get ::<- offsetX
            },

            y : {
                set ::(value => Number) {
                    when(value == offsetY) empty;
                    offsetY = value;
                    redrawLines();
                },
                get ::<- offsetY
            },
            
            layer : {
                set ::(value => Number) {
                    layer = value;
                }
            },

            scrollX : {
                get ::<- scrollX,
                set ::(value) {
                    if (value < 0) value = 0;
                    when (value->floor == scrollX->floor) empty;
                    scrollX = value;
                    redrawLines();
                    
                }
            },

            scrollY : {
                get ::<- scrollY,
                set ::(value) {
                    when (lines->keycount <= TEXT_AREA_HEIGHT) scrollY = 0;
                    if (value > lines->keycount - TEXT_AREA_HEIGHT) value = lines->keycount - TEXT_AREA_HEIGHT;
                    if (value < 0) value = 0;
                    when (value->floor == scrollY->floor) empty;
                    scrollY = value;
                    redrawLines();
                }
            },
            
            setScroll ::(x, y) {
                this.scrollX = x;
                this.scrollY = y;
            },
                        
                        
            widthChars : {
                set ::(value) {
                    TEXT_AREA_WIDTH = value;
                }
            },
            
            shown : {
                get ::<- shown,
                set ::(value => Boolean) {
                    shown = value;
                    redrawLines();
                    this.editable = shown;
                }
            },
            
            
            width : {
                get ::<- TEXT_AREA_WIDTH * GLYPH_WIDTH                            
            },

            heightChars : {
                set ::(value) {
                    TEXT_AREA_HEIGHT = value;
                }
            },
            
            
            height : {
                get ::<- TEXT_AREA_HEIGHT * GLYPH_HEIGHT                            
            },

            getSelectedText :: {
                when(selectActive == false) '';
                @:bounds = getSelectedBounds();

                when(bounds.toY == bounds.fromY) ::<= {
                    return lines[bounds.fromY]->substr(from:bounds.fromX, to:bounds.toX);
                };
                @out = '';



                [bounds.fromY, bounds.toY+1]->for(do:::(i) {
                    when(i == bounds.fromY) ::<= {
                        out = out + lines[i]->substr(from:bounds.fromX, to:lines[i]->length-1);
                    };

                    when(i == bounds.toY) ::<= {
                        out = out + '\n' + lines[i]->substr(from:0, to:bounds.toX);

                    };

                    out = out + '\n' + lines[i];

                });
                return out;                
            },
            
            editable : {
                set::(value => Boolean) {
                    when(value == true) ::<= {
                        when(inputCallbackID != empty) empty;
                        
                        ctrlCallbackID = SES.Input.addCallback(
                            device:SES.Input.DEVICES.KEYBOARD,
                            callback:::(event, text, key) {
                                if(event == SES.Input.EVENTS.KEY_DOWN && key == SES.Input.KEYS.LCTRL) ctrlMod = true;
                                if(event == SES.Input.EVENTS.KEY_UP   && key == SES.Input.KEYS.LCTRL) ctrlMod = false;
                                if(event == SES.Input.EVENTS.KEY_DOWN && key == SES.Input.KEYS.LSHIFT) shiftMod = true;
                                if(event == SES.Input.EVENTS.KEY_UP   && key == SES.Input.KEYS.LSHIFT) shiftMod = false;
                                if(event == SES.Input.EVENTS.KEY_DOWN && key == SES.Input.KEYS.RSHIFT) shiftMod = true;
                                if(event == SES.Input.EVENTS.KEY_UP   && key == SES.Input.KEYS.RSHIFT) shiftMod = false;
                            }
                        );
                        inputCallbackID = SES.Input.addCallback(
                            device:SES.Input.DEVICES.KEYBOARD,
                            callback:keyboardCallback
                        );            
                        pointerCallbackID = SES.Input.addCallback(
                            device:SES.Input.DEVICES.POINTER0,
                            callback:::(event, x, y, button) {
                                
                                match(event) {
                                  (SES.Input.EVENTS.POINTER_BUTTON_UP): ::<= {
                                    mouseDownMod = false;
                                  },

                                  
                                  (SES.Input.EVENTS.POINTER_MOTION): ::<= {
                                    when(mouseDownMod == false) empty;
                                    @:p = this.pixelCoordsToCursor(x, y);
                                    if (p.x != cursorX || p.y != cursorY) ::<= {
                                        // highlight active
                                        selectActive = true;
                                        
                                    };


                                    if (selectCursorX != p.x || selectCursorY != p.y) ::<= {
                                        selectCursorX = p.x;
                                        selectCursorY = p.y;
                                        redrawLines();
                                    };

                                  },
                                    

                                  (SES.Input.EVENTS.POINTER_BUTTON_DOWN): ::<= {
                                    selectActive = false;
                                    mouseDownMod = true;
                                    mouseDownX = x;
                                    mouseDownY = y;
                                    @:a = this.pixelCoordsToCursor(x, y);        
                                    this.moveCursor(x:a.x, y:a.y);
                                    redrawLines();
                                  }
                                };


                            }
                        );
                        redrawLines();
                    };
                    
                    when(inputCallbackID == empty) empty;
                    SES.Input.removeCallback(id:inputCallbackID, device:SES.Input.DEVICES.KEYBOARD);
                    SES.Input.removeCallback(id:pointerCallbackID, device:SES.Input.DEVICES.POINTER0);
                    SES.Input.removeCallback(id:ctrlCallbackID, device:SES.Input.DEVICES.KEYBOARD);
                    inputCallbackID = empty;
                    redrawLines();
                },
                
            },
            
            scrollable : {
                set::(value => Boolean) {
                    when(value == true) ::<= {
                        when(scrollCallbackID != empty) empty;
                        
                        @isDown = false;
                        
                        @lastX = 0;
                        @lastY = 0;
                        @ripple = false;
                        scrollCallbackID = SES.Input.addCallback(
                            device:SES.Input.DEVICES.POINTER0,
                            callback:::(event, x, y, button) {
                                if (event == SES.Input.EVENTS.POINTER_BUTTON_DOWN) holdMod = true;
                                if (event == SES.Input.EVENTS.POINTER_BUTTON_UP  ) holdMod = false;

                                if (event == SES.Input.EVENTS.POINTER_MOTION) ::<= {
                                    if (holdMod && ctrlMod) ::<= {
                                        if (ripple) ::<= {
                                            this.setScroll(
                                                x: this.scrollX - (x - lastX)/2,
                                                y: this.scrollY - (y - lastY)/2
                                            );
                                        };
                                        ripple = !ripple;
                                    };
                                    
                                    lastX = x;
                                    lastY = y;
                                };

                                if (event == SES.Input.EVENTS.POINTER_SCROLL) ::<= {
                                    this.scrollX -= x;
                                    this.scrollY -= y;                                                
                                };    
                                
                            }
                        );
                        

                    };

                    when(scrollCallbackID == empty) empty;
                    SES.Input.removeCallback(id:scrollCallbackID, device:SES.Input.DEVICES.POINTER0);
                    scrollCallbackID = empty;
                    

                }
            },
            
            text : {
                get :: {
                    @linesReal = [];
                    lines->foreach(do:::(i, line) {
                        if (i != 0)
                            linesReal->push(value:'\n');
                        linesReal->push(value:line);
                        
                    });
                    return String.combine(strings:linesReal);
                },
                
                
                set ::(value)  {
                    cursorX = 1;
                    cursorY = 0;

                    if (value == '' || value == '\n') ::<= {
                        lines = [''];
                        colors = [[]];
                    } else ::<= {                                                                       
                        lines = value->split(token:'\n');
                        [0, lines->keycount]->for(do:::(i) {
                            @:color = [];;
                            @:line = lines[i];                            
                            [0, line->length]->for(do:::(n) {
                                color->push(value:defaultPalette_);
                            });
                            
                            colors[i] = color;
                        });

                        lines->foreach(do:::(i, text) {
                            if (onChange_ != empty) onChange_(prevLine:i, prevText:'');
                        });
                    };

                    if (LINE_LIMIT > 0) ::<= {
                        lines = lines->subset(from:0, to:LINE_LIMIT);
                        colors = colors->subset(from:0, to:LINE_LIMIT);
                        if (lines == empty) ::<= {
                            lines = [''];
                            colors = [[]];
                        };
                    };


                    redrawLines();  
                },
            },

            addCh ::(ch) {
                // else, just normal text
                insertText(text:ch);
                redrawLines();
            },

            addText ::(text) {
                text->split(token:'\n')->foreach(do:::(index, line) {
                    if (index > 0) ::<= {
                        cursorY+=1;
                        cursorX=0;
                        lines->insert(value:'', at:cursorY);  
                        colors->insert(value:[], at:cursorY);              
                        movedDown();
                        movedLeft();
                    };
                    insertText(text:line);
                });

                redrawLines();
            },



            deleteLineText::(numChars => Number) {
                // cursor can be [0, line->length]
                when(cursorX == 0) empty;
                when(lines[cursorY]->length == 0) empty;
                
                @:oldLine = lines[cursorY];

                when(numChars >= lines[cursorY]->length && cursorX >= lines[cursorY]->length) ::<= {
                    lines[cursorY] = '';
                    colors[cursorY] = [];
                    cursorX = 0;
                };

                when(numChars >= cursorX) ::<= {
                    colors[cursorY] = colors[cursorY]->subset(from:cursorX, to: lines[cursorY]->length-1);
                    lines[cursorY] = lines[cursorY]->substr(from:cursorX, to: lines[cursorY]->length-1);
                    cursorX = 0;
                };

                when(cursorX > lines[cursorY]->length-1) ::<={
                    colors[cursorY] = colors[cursorY]->subset(from:0, to:lines[cursorY]->length-numChars-1);
                    lines[cursorY] = lines[cursorY]->substr(from:0, to:lines[cursorY]->length-numChars-1);
                    cursorX -= numChars;
                };
                
                colors[cursorY] = [
                    ...(colors[cursorY]->subset(from:0, to:cursorX-numChars-1)),
                    ...(colors[cursorY]->subset(from:cursorX, to: lines[cursorY]->length-1))
                ];
                lines[cursorY] = 
                    lines[cursorY]->substr(from:0, to:cursorX-numChars-1) +
                    lines[cursorY]->substr(from:cursorX, to: lines[cursorY]->length-1)
                ;
                cursorX -= numChars;
                if (onChange_ != empty) onChange_(prevText:oldLine, prevLine:cursorY);
                redrawLines();

            },
            
            getLine ::(index => Number) => String {
                return lines[index];
            },
            
            getLineCount:: {
                return lines->keycount;
            },
            
            lineLimit : {
                set ::(value) <- LINE_LIMIT = value
            },
            
            setScrollBottom :: {
                if (lines->keycount > TEXT_AREA_HEIGHT) ::<= {
                    scrollY = lines->keycount - TEXT_AREA_HEIGHT;
                };
                redrawLines();
            },
            
            
            // returns an x y set of cursor a cursor position 
            // corresponding to the x y pixel given
            pixelCoordsToCursor::(x, y) {
                @ycursor = scrollY + ((y - offsetY) / GLYPH_HEIGHT);
                if (ycursor < 0) ycursor = 0;
                if (ycursor > lines->keycount-1) ycursor = lines->keycount-1;
                
                ycursor = ycursor->floor;
                
                @xcursor = scrollX + ((x - offsetX) / GLYPH_WIDTH);
                if (xcursor < 0) xcursor = 0;
                if (xcursor > lines[ycursor]->length) xcursor = lines[ycursor]->length;
                
                return {x:xcursor->floor, y:ycursor};
            },
            
            
            // Gets a screen pixel corresponding to the 
            // current cursor location
            cursorToPixelCoords :: {
                @y = offsetY + (cursorY - scrollY) * GLYPH_HEIGHT;                                
                if (y < 0) y = 0;

                @x = offsetX + (cursorX - scrollX) * GLYPH_WIDTH;
                if (x < 0) x = 0;
                
                return {x:x, y:y};
            },
            
            
            moveCursor ::(x, y) {
                cursorX = if (x == empty) cursorX else x;
                cursorY = if (y == empty) cursorY else y;
                redrawLines();
                if (onNavVer_ != empty) onNavVer_(dir:0);
                if (onNavHor_ != empty) onNavHor_();

            },
            
            cursorY : {
                get :: <- cursorY
            },

            cursorX : {
                get :: <- cursorX
            },
            
            // clears all characters from the drawn view


            // in completion mode, the up / down / enter keys 
            // are ignored            
            completionMode : {
                set ::(value) <- completionMode = value,
                get ::(value) <- completionMode
            },
            
            defaultPalette : {
                set::(value) {
                    defaultPalette_ = value;
                    redrawLines();                    
                }
            },
            
            
            
            setColor ::(paletteID => Number, fromX => Number, fromY => Number, toX => Number, toY => Number) {
                when(toY < fromY) print(message:'toY'+toY+' fromY'+fromY);
                when(toY >= colors->keycount || fromY >= colors->keycount) print(message:'toY'+toY+' numColLines'+colors->keycount);
                when(toY < 0) empty;
                when(fromY == toY) ::<= {
                    @color = colors[fromY];
                    [fromX, toX+1]->for(do:::(x) {
                        color[x] = paletteID;
                    });
                };
                
                
                when(fromY < toY) ::<= {
                    @color = colors[fromY];
                    [fromX, color->length]->for(do:::(x) {
                        color[x] = paletteID;
                    });


                    [fromY, toY]->for(do:::(y) {
                        color = colors[y];
                        [0, color->length]->for(do:::(x) {
                            color[x] = paletteID;
                        });
                    });

                    color = colors[toY];
                    [0, toX+1]->for(do:::(x) {
                        color[x] = paletteID;
                    });

                };
            
            }

        };
    }
);



