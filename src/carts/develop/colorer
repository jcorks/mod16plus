@:Mod16 = import(module:'Mod16Plus.Core');
@:class = import(module:'Matte.Core.Class');
@:Cartridge = Mod16.Cartridge;

@:View = Cartridge.import(source:'view');
@:Fetcher = Cartridge.import(source:'fetcher');
@:Project = Cartridge.import(source:'project');


@:Widgets = Cartridge.subCartridge(name:'widgets');

@:UILabel = Widgets.UILabel;
@:UI = Widgets.UI;
@:UIFlat = Widgets.UIFlat;
@:UITile = Widgets.UITile;
@:UIScrollable = Widgets.UIScrollable;
@:UIButton = Widgets.UIMousable;
@:UIRadioLayout = Widgets.UIRadioLayout;
@:UILayout = Widgets.UILayout;
@:hexDisplay = Cartridge.import(source:'hexdisplay');



@:ICON_TILE_DATA = [
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 0, 0, 0, 1,
    1, 1, 1, 0, 1, 0, 0, 1,
    1, 1, 1, 1, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    0, 0, 0, 0, 0, 0, 0, 0,
];



@:REMOVE_TILE_DATA = [
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 0, 1, 0, 0, 1, 0, 1,
    1, 0, 0, 1, 1, 0, 0, 1,

    1, 0, 0, 1, 1, 0, 0, 1,
    1, 0, 1, 0, 0, 1, 0, 1,
    1, 0, 0, 0, 0, 0, 0, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
];


@:PREVIEW_PALETTE_TILE_DATA =  [
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
    1, 1, 2, 2, 3, 3, 4, 4,
];

@:BUTTON_TILE1_DATA = [
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1,
    1, 1, 1, 1, 1, 1, 1, 1
];

@:BUTTON_TILE2_DATA = [
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
    2, 2, 2, 2, 2, 2, 2, 2,
];

@:BUTTON_TILE3_DATA = [
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3,
];


@:BUTTON_TILE4_DATA = [
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
    4, 4, 4, 4, 4, 4, 4, 4,
];

@:INACTIVE_PALETTE_DATA = [
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0],
    [0, 0, 0, 0]
];


@:Colorer = class(
    inherits : [UI],
    define:::(this) {
        @:Window = Cartridge.import(source:'window');
        


        @:palette = [
            [0.1, 0.1, 0.1, 0.1],
            [0.3, 0.3, 0.3, 0.3],
            [0.7, 0.7, 0.7, 0.7],
            [0.9, 0.9, 0.9, 0.9],
        ];




        @:makeChoiceItem ::(index) {
            @:label = UILabel.new(text:'');
            @:icon = UITile.new(paletteData:INACTIVE_PALETTE_DATA, tileData:PREVIEW_PALETTE_TILE_DATA);
            @:box = UIFlat.new(children:[
                [label, 0.8],
                [icon, 0.2]
            ]);
            return box;
        };


        @:paletteChoices = [
            makeChoiceItem(index:0),
            makeChoiceItem(index:1),
            makeChoiceItem(index:2),
            makeChoiceItem(index:3),
            makeChoiceItem(index:4),
            makeChoiceItem(index:5)
        ];

        
        
        
        @:choiceRadio = UIRadioLayout.new(
            choices : [
                paletteChoices[0],
                paletteChoices[1],
                paletteChoices[2],
                paletteChoices[3],
                paletteChoices[4],
                paletteChoices[5]
            ]
        );   
        
        // reads a project palette and dumps it into an active palette id
        @:readPalette::(paletteID, storedPaletteIndex => Number) {
            @:data = Project.openPalette(id:storedPaletteIndex);
            @:dataFormatted = [
                [data[0], data[1], data[2]],
                [data[3], data[4], data[5]],
                [data[6], data[7], data[8]],
                [data[9], data[10], data[11]]
            ];
            return dataFormatted;
        };
        

        
        @:resetRadioChoices = :: {
            @paletteData = Project.palettes;
            paletteData->push(value:['Add Palette']);
            @:top = scrollable.currentScrollPosition;
            
            scrollable.setupPage(itemCount:Project.palettes->keycount+1, itemsPerPage:6);

            
            @i = 0;
            [::] {
                [top, paletteData->keycount]->for(do:::(index) {
                    paletteChoices[i].show();

                    if (index != paletteData->keycount-1) ::<= {
                        paletteChoices[i].children[0].text = hexDisplay(number:paletteData[index][0]);
                        paletteChoices[i].children[1].palette = readPalette(storedPaletteIndex:paletteData[index][0]);
                    } else ::<= { 
                        paletteChoices[i].children[1].palette = INACTIVE_PALETTE_DATA;
                        paletteChoices[i].children[0].text = 'Add Palette';


                    };
                        
                    i+=1;
                    
                    when(i == 6) send();
                });
                
                [i, 6]->for(do:::(index) {
                    paletteChoices[i].hide();
                });
            };
        };
        
        
        @chosenPalettesSlot;
        
        choiceRadio.onChoose = ::(choice){
            @paletteData = Project.palettes;
            @:radioChoice = choice;
            choice += scrollable.currentScrollPosition;
            chosenPalettesSlot = choice;
            // add new palette!
            when (choice == paletteData->keycount) ::<= {
                Window.entryDialog(text:'Palette ID:', onEntry::(text) {
                    [::] {
                        Project.newPalette(id:Number.parse(string:text));
                    } : {
                        onError ::(message) {
                            Window.alert(text:'Error: ' + message.data);
                        }
                    };
                    resetRadioChoices();
                    Project.save();
                    choiceRadio.choice = paletteData->keycount-1;
                });
            };
            
            
            // deselect
            when(choice < 0) ::<= {
                paletteBox.children[0].text = 'No palette';
                paletteBox.children[1].children[0].palette = INACTIVE_PALETTE_DATA;
                paletteBox.children[2].children[0].palette = INACTIVE_PALETTE_DATA;
                paletteBox.children[3].children[0].palette = INACTIVE_PALETTE_DATA;
                paletteBox.children[4].children[0].palette = INACTIVE_PALETTE_DATA;
            };
            
            
            // invalid
            when (choice > paletteData->keycount) ::<= {
                choiceRadio.choice = -1;
                paletteBox.children[0].text = 'No palette';
                paletteBox.children[1].children[0].palette = INACTIVE_PALETTE_DATA;
                paletteBox.children[2].children[0].palette = INACTIVE_PALETTE_DATA;
                paletteBox.children[3].children[0].palette = INACTIVE_PALETTE_DATA;
                paletteBox.children[4].children[0].palette = INACTIVE_PALETTE_DATA;
            };

            // select palette 
            paletteBox.children[0].text = 'Palette: '+hexDisplay(number:paletteData[choice][0]);
            @:palette = readPalette(storedPaletteIndex:paletteData[choice][0]); 

            paletteBox.children[1].children[0].palette = palette;
            paletteBox.children[2].children[0].palette = palette;
            paletteBox.children[3].children[0].palette = palette;
            paletteBox.children[4].children[0].palette = palette;
        };

        @:scrollable = UIScrollable.new(
            child: choiceRadio,
            onScroll::(itemTop, itemCount, itemsPerPage) {
                resetRadioChoices();
                
                when(chosenPalettesSlot == empty) empty;
                choiceRadio.choice = chosenPalettesSlot - itemTop;
            },
            itemCount: 1,  
            itemsPerPage: 6
        );



        
        paletteChoices[0].children[0].text = 'Add Palette';


        @:hexToByte = ::<= {
            @:table = {
                '0' : 0,
                '1' : 1,
                '2' : 2,
                '3' : 3,
                '4' : 4,
                '5' : 5,
                '6' : 6,
                '7' : 7,
                '8' : 8,
                '9' : 9,
                'a' : 10,
                'b' : 11,
                'c' : 12,
                'd' : 13,            
                'e' : 14,            
                'f' : 15,            
                'A' : 10,
                'B' : 11,
                'C' : 12,
                'D' : 13,            
                'E' : 14,            
                'F' : 15
            };
            return ::(hex => String) {
                return table[hex->charAt(index:0)]*16 + table[hex->charAt(index:1)]; 
            };
        };

        @:makePaletteChoiceItem ::(index, tile){
            @:tile = UITile.new(paletteData:INACTIVE_PALETTE_DATA, tileData:tile);
            @:button = UIButton.new(child:tile);
            ::<= {
                button.onClick = ::{
                    Window.entryDialog(
                        text: 'Hex RGB:',
                        onEntry ::(text){
                            when(text->length != 6) ::<= {
                                Window.alert(text:'Error! Needs RRGGBB');
                            };
                        
                            @:r = hexToByte(hex:text->substr(from:0, to:1));
                            @:g = hexToByte(hex:text->substr(from:2, to:3));
                            @:b = hexToByte(hex:text->substr(from:4, to:5));
                                
                            @:entry = Project.palettes[chosenPalettesSlot];
                            @:fullPalette = Project.openPalette(id:entry[0]);
                            fullPalette[index*3]     = r / 255.0;
                            fullPalette[index*3 + 1] = g / 255.0;
                            fullPalette[index*3 + 2] = b / 255.0;
                            Project.savePalette(id:entry[0], paletteColors:fullPalette);
                            tile.palette = readPalette(storedPaletteIndex:entry[0]); 

                            resetRadioChoices();                            
                            Project.save();
                        }
                    );
                };
            };
            
            tile.resizeable = true;
            return button;
        };

        @:paletteBox = UILayout.new(
            children: [
                [UILabel.new(text:'No Palette'), 0.1],
                [makePaletteChoiceItem(index:0, tile:BUTTON_TILE1_DATA), 0.2],
                [makePaletteChoiceItem(index:1, tile:BUTTON_TILE2_DATA), 0.2],
                [makePaletteChoiceItem(index:2, tile:BUTTON_TILE3_DATA), 0.2],
                [makePaletteChoiceItem(index:3, tile:BUTTON_TILE4_DATA), 0.2]
            ]
        );

        @:mainbox = UIFlat.new(
            children: [
                [scrollable, 0.5],
                [paletteBox, 0.5]
            ]
        );
        

        this.addChild(child:mainbox, sizeRequest:1);

                
        this.events.installHooks(events: {
            onMove ::(detail) {
                mainbox.move(x:this.x, y:this.y);
            },
            
            onResize ::(detail) {
                mainbox.resize(width:this.width, height:this.height);
            },
            
            onShow ::(detail) {
                resetRadioChoices();            
            }
        });









        
        this.interface = {
            // All the menus within the 
            // view. Should be an array of 
            // arrays, where each inner array 
            // is a string for the menu and a function
            // called when clicking the actions.
            menus : {
                get :: <- [
                    [palette, REMOVE_TILE_DATA, ::{
                        @:selected = choiceRadio.choice + scrollable.currentScrollPosition;                   
                        @paletteData = Project.palettes;
                        @:selectedPalette = paletteData[selected];                        
                        
                        Window.question(text:'Remove palette '+ hexDisplay(number:selectedPalette[0]) +'?',
                            onResponse ::(which) {
                                when(!which) empty;
                                
                                Project.removePalette(id:selectedPalette[0]);            
                                Project.save();              
                                resetRadioChoices();
                                choiceRadio.choice = -1;
                                
                            }
                        
                        );
                    }],                 
                ]
            },

            icon : {
                get :: {
                    return ICON_TILE_DATA;
                }
            },
          
        };
        

        
    }
    
);



return Colorer;
